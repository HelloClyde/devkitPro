--// DO NOT EDIT THIS FILE //--

_KvS = {_Ua = true,  _Tr = Timer.new(),  _Tp_ = 1,  _T_K_ = 0,  _C_a = 0,  _C_b = 0,  _C_c = 0,  _C_d = 0,  _C_e = 0,  _C_f = 0,  _C_g = 0,  _C_h = 0,  _C_i  = 0,  _C_j  = 0,  _C_k = 0,  _C_l = 0}
function _KvS:_K_D__(_K_C__)
  local t_TC_ = self._T_K_ - _K_C__
  return _K_C__ > 0 and (t_TC_ == 0 or t_TC_ > 350)
end
function _KvS:g_GR(_K_C__)
  if _K_C__ == 0 then return 0 end
  local t_TC_ = self._T_K_ - _K_C__
  if t_TC_ == 0  then return 1 end
  if t_TC_ > 350 then return self._Tp_ end
  return 0
end
function _KvS:GGH_tR__()
  local H = _KvS:g_GR(self._C_d) - _KvS:g_GR(self._C_c)
  return H + math.ceil(self._PSS__ / 20 - 0.5)
end
function _KvS:GGV_tR__()
  local V = _KvS:g_GR(self._C_b) - _KvS:g_GR(self._C_a)
  return V + math.ceil(self._PAS__ / 20 - 0.5)
end
function _KvS:GGL_H()
  if self._T_KL_HR then return  1 end
  if self._T_KL_HL then return -1 end
  return 0
end
function _KvS:GGL_V()
  if self._T_KL_HD then return  1 end
  if self._T_KL_HU then return -1 end
  return 0
end
function _KvS:GGR_H()
  if self._T_KL_VR then return  1 end
  if self._T_KL_VL then return -1 end
  return 0
end
function _KvS:GGR_V()
  if self._T_KL_VD then return  1 end
  if self._T_KL_VU then return -1 end
  return 0
end
function _KvS:_DU_il()
  local _DU_ir = Controls.read()
  local R_EaL, R_EaR, R_EaX = false, false, false
  local function aCDZ_Z(aCDZ_Zaa_PPPrrr, _VVVVV_)
    if aCDZ_Zaa_PPPrrr >= _VVVVV_ then
      return aCDZ_Zaa_PPPrrr - _VVVVV_
    elseif aCDZ_Zaa_PPPrrr >= -_VVVVV_ then
      return 0
    else
      return aCDZ_Zaa_PPPrrr + _VVVVV_
    end
  end
  if self._Ua then
    self._PSS__ = aCDZ_Z(_DU_ir:analogX(), 32)
    self._PAS__ = aCDZ_Z(_DU_ir:analogY(), 32)
  else
    self._PSS__ = 0
    self._PAS__ = 0
  end
  self.LU = _DU_ir:up()  self.LD = _DU_ir:down()  self.LL = _DU_ir:left()  self.LR = _DU_ir:right()  self.RU = _DU_ir:triangle()  self.RD = _DU_ir:cross()  self.RL = _DU_ir:square()  self.RR = _DU_ir:circle()  self.L  = _DU_ir:l()  self.R  = _DU_ir:r()  self.ST = _DU_ir:start()  self.SL = _DU_ir:select()  self._T_K_ = self._Tr:start()
  if self.LU then
    R_EaL = true
    self._RRRRDDD__U = false
    self._T_KL_HU = self._C_a == 0
    if self._T_KL_HU then self._C_a = self._T_K_ end
  else
    self._RRRRDDD__U = self._C_a > 0
    self._T_KL_HU = false
    self._C_a = 0
  end
  if self.LD then
    R_EaL = true
    self._RRRRDDD__D = false
    self._T_KL_HD = self._C_b == 0
    if self._T_KL_HD then self._C_b = self._T_K_ end
  else
    self._RRRRDDD__D = self._C_b > 0
    self._T_KL_HD = false
    self._C_b = 0
  end
  if self.LL then
    R_EaL = true
    self._RRRRDDD__L = false
    self._T_KL_HL = self._C_c == 0
    if self._T_KL_HL then self._C_c = self._T_K_ end
  else
    self._RRRRDDD__L = self._C_c > 0
    self._T_KL_HL = false
    self._C_c = 0
  end
  if self.LR then
    R_EaL = true
    self._RRRRDDD__R = false
    self._T_KL_HR = self._C_d == 0
    if self._T_KL_HR then self._C_d = self._T_K_ end
  else
    self._RRRRDDD__R = self._C_d > 0
    self._T_KL_HR = false
    self._C_d = 0
  end
  if self.RU then
    R_EaR = true
    self._RRRRaaa__RU = false
    self._T_KL_VU = self._C_e == 0
    if self._T_KL_VU then self._C_e = self._T_K_ end
  else
    self._RRRRaaa__RU = self._C_e > 0
    self._T_KL_VU = false
    self._C_e = 0
  end
  if self.RD then
    R_EaR = true
    self._RRRRaaa__RD = false
    self._T_KL_VD = self._C_f == 0
    if self._T_KL_VD then self._C_f = self._T_K_ end
  else
    self._RRRRaaa__RD = self._C_f > 0
    self._T_KL_VD = false
    self._C_f = 0
  end
  if self.RL then
    R_EaR = true
    self._RRRRaaa__RL = false
    self._T_KL_VL = self._C_g == 0
    if self._T_KL_VL then self._C_g = self._T_K_ end
  else
    self._RRRRaaa__RL = self._C_g > 0
    self._T_KL_VL = false
    self._C_g = 0
  end
  if self.RR then
    R_EaR = true
    self._RRRRaaa__RR = false
    self._T_KL_VR = self._C_h == 0
    if self._T_KL_VR then self._C_h = self._T_K_ end
  else
    self._RRRRaaa__RR = self._C_h > 0
    self._T_KL_VR = false
    self._C_h = 0
  end

  if self.L then
    R_EaX = true
    self._RRRRDDD__ = false
    self._T_KL_H = self._C_i == 0
    if self._T_KL_H then self._C_i = self._T_K_ end
  else
    self._RRRRDDD__ = self._C_i > 0
    self._T_KL_H = false
    self._C_i = 0
  end
  if self.R then
    R_EaX = true
    self._RRRRaaa__R = false
    self._T_KL_V = self._C_j == 0
    if self._T_KL_V then self._C_j = self._T_K_ end
  else
    self._RRRRaaa__R = self._C_j > 0
    self._T_KL_V = false
    self._C_j = 0
  end
  if self.ST then
    R_EaX = true
    self._RRRRaaa__ST = false
    self.TTTHHHSSSST = self._C_k == 0
    if self.TTTHHHSSSST then self._C_k = self._T_K_ end
  else
    self._RRRRaaa__ST = self._C_k > 0
    self.TTTHHHSSSST = false
    self._C_k = 0
  end
  if self.SL then
    R_EaX = true
    self._RRRRaaa__SL = false
    self.TTTHHHSSSSL = self._C_l == 0
    if self.TTTHHHSSSSL then self._C_l = self._T_K_ end
  else
    self._RRRRaaa__SL = self._C_l > 0
    self.TTTHHHSSSSL = false
    self._C_l = 0
  end
  self.PRPRPR_L  = R_EaL
  self.PRPRPR_R  = R_EaR
  self.PRPRPR_X  = R_EaX
  self.PRPRPR_LR = R_EaL or R_EaR
  self.PRPRPR_   = R_EaL or R_EaR or R_EaX
  if not self.PRPRPR_ then
    self._Tr:reset(1)
  end
  return self.PRPRPR_
end
True   = true False  = false Screen = screen
Res = {  _TBS___   = Image.load("Ciba/Images/Buttons.png")}
White = Color.new(255,255,255) Black = Color.new(  0,  0,  0) Red   = Color.new(255,  0,  0) Green = Color.new(  0,255,  0) mxmxaeee  = Color.new(  0,  0,255)
function _TBSDR___(_TBSDopR___, x, y, w, h, Color)
  _TBSDopR___ = _TBSDopR___ or screen
  _TBSDopR___:drawLine(x, y, x + w, y, Color)
  _TBSDopR___:drawLine(x, y, x, y + h, Color)
  _TBSDopR___:drawLine(x + w, y, x + w, y + h, Color)
  _TBSDopR___:drawLine(x + w, y + h, x, y + h, Color)
end
function _TBSDccRLT___(__VVVVV_, _mMmM, _mMm)
    return math.min(math.max(__VVVVV_, _mMmM), _mMm)
end
function CF__eid(SRC, DST)
  SRC = io.open(SRC, "r")
  if SRC then
    DST = io.open(DST, "w")
    while true do
      local _atatx = SRC:read(1024 * 8)
      if not _atatx then break end
      DST:write(_atatx)
    end
    SRC:close()
    DST:close()
  end
end
_MAFD_ = {
  _MAFDa_ = Image.load("Ciba/FontData/ASC.png"),  _MAFDb_ = {},  _MAFDc_ = {
           [1] = Image.load("Ciba/FontData/GB_1.png"),[2] = Image.load("Ciba/FontData/GB_2.png"),[3] = Image.load("Ciba/FontData/GB_3.png"), [4] = Image.load("Ciba/FontData/GB_4.png"),[5] = Image.load("Ciba/FontData/GB_5.png"),[6] = Image.load("Ciba/FontData/GB_6.png"),[7] = Image.load("Ciba/FontData/GB_7.png"),[8] = Image.load("Ciba/FontData/GB_8.png") }}
function _MAFD_:_MAFDd_(Color_Name)
  if not Color_Name then return self._MAFDa_ end
  if not _MAFD_._MAFDb_[Color_Name] then
    local width = self._MAFDa_:width()
    local height = self._MAFDa_:height()
    local Img = Image.createEmpty(width, height)
    Img:blit(0, 0, self._MAFDa_)
    for _PAS__ = 0, 35 do
      for _PSS__ = 0, width - 1 do
        local Pixel_Color = Img:pixel(_PSS__, _PAS__):colors()
        if Pixel_Color.a ~= 0 then
          Img:pixel(_PSS__, _PAS__, Color_Name)
        end
      end
    end
    self._MAFDb_[Color_Name] = Img
  end
  return _MAFD_._MAFDb_[Color_Name]
end
function _MAFD_:print(x, y, _abc_FFH, _TBSDopR___, Color_Name, _TBSDccRLT___, Height)
  if not _abc_FFH then return nil end
  local _TBSDccRLT____Left = x
  local _abc_FFDd, _zzz_adft_TC_ = 1, string.len(_abc_FFH)
  local Font = self:_MAFDd_(Color_Name)
  _TBSDopR___ = _TBSDopR___ or screen
  while _abc_FFDd <= _zzz_adft_TC_ do
    local Byte = string.byte(_abc_FFH, _abc_FFDd)
    _abc_FFDd = _abc_FFDd + 1
    if Byte < 128 and Byte >= 32 then
      _TBSDopR___:blit(x, y, Font, math.mod(Byte, 32) * 6, math.floor(Byte / 32 - 1) * 12, 6, 12)
      x = x + 6
    elseif Byte > 160 then
      local Byte_2nd = string.byte(_abc_FFH, _abc_FFDd)
      _abc_FFDd = _abc_FFDd + 1
      if not Byte_2nd then break end
      local _abc_FFDda = Byte - 160
      local _abc_FFDba = Byte_2nd - 161
      if _abc_FFDda > 12 then
        _abc_FFDba = 96 * math.mod(_abc_FFDda - 1, 12) + _abc_FFDba 
        _abc_FFDda = math.floor((_abc_FFDda - 1) / 12) + 1
      else
        _abc_FFDba = 96 * _abc_FFDda - (96 - _abc_FFDba)
        _abc_FFDda = 1
      end
      if _abc_FFDda <= 8 then
        if _TBSDccRLT___ then
          if x > _TBSDccRLT___ then y = y + Height ; x = _TBSDccRLT____Left end
        end
        _TBSDopR___:blit(x, y, _MAFD_._MAFDc_[_abc_FFDda], math.mod(_abc_FFDba, 32) * 12, math.floor(_abc_FFDba / 32) * 12 , 12, 12)
      end
      x = x + 12
    end
  end
  return x, y
end
ASC = {}
GREY  = Color.new(160,160,160) BLACK = Color.new(  0,  0,  0) _MAFD_:_MAFDd_(BLACK) _MAFD_:_MAFDd_(GREY)
function ASC:print(x, y, _abc_FFH, _TBSDccRLT____Width, _TBSDopR___, color)
  _TBSDccRLT____Width = _TBSDccRLT____Width or 480
  color = color or BLACK
  local _TBSDccRLT____Left = x
  local _MAFDa_ = _MAFD_:_MAFDd_(Color_Name)
  local _abc_FFDd, _zzz_adft_TC_ = 1, string.len(_abc_FFH)
  _TBSDopR___ = _TBSDopR___ or screen
  while _abc_FFDd <= _zzz_adft_TC_ do
    local Byte = string.byte(_abc_FFH, _abc_FFDd)
    _abc_FFDd = _abc_FFDd + 1
    if  Byte < 32 then
      if Byte == 10 then y = y + 12 ; x = _TBSDccRLT____Left end
    else
      if x > _TBSDccRLT____Width then y = y + 12 ; x = _TBSDccRLT____Left end
      _TBSDopR___:blit(x, y, _MAFD_._MAFDb_[color], math.mod(Byte, 32) * 6, math.floor(Byte / 32 - 1) * 12, 6, 12)
      x = x + 6
    end
  end
  return x, y
end
_abc_xx = {goxzy_Box = Image.load("Ciba/Images/InputBox.png"), _TBS___  = Res._TBS___, Keyboard = {      [false] = Image.load("Ciba/Images/Keyboard.png"),[true]  = Image.load("Ciba/Images/CapsLock.png") }, Palette = {
    [false] = {[0]="1234567890", [1]="qwertyuiop", [2]="zasdfghjkl", [3]="xc\bvbnm .;", [4]="-'=()\\/,[]" }, [true]  = {[0]="!@#$%^&*~`",[1]="QWERTYUIOP", [2]="ZASDFGHJKL", [3]="XC\tVBNM\n.:", [4]="_\"+<>|?,{}" } },}
function _abc_xx.new()
  local _zzz_ann = setmetatable( {
    eee_Cab = "",
    eee_Lllt_TC_ = 1,
    eee_ssss = false,
    eee_sssd = false,
    eee_seeea = false,
    eee_seccc = {},
    eee_Issssssss = nil,
    _zzz_aa = false,
    _zzz_ab = true,
    _zzz_ac = false,
    _zzz_ad = false,
    x = 0,
    y = 0,
    _zzz_adf = nil },
    { __index = _abc_xx } )
  return _zzz_ann
end
function _abc_xx:_zzz_aii()
  self.des_xz = false
  self.x = 0
  self.y = 0
  self._zzz_adf = nil
  self.eee_Cab = ""
end
function _abc_xx:des_xzaw(_TBSDopR___, x, y)
  if _TBSDopR___ then
    _TBSDopR___:blit(x, y, self.Keyboard[self._zzz_ad])
    eee_X, eee_Y = x, y
    if self._zzz_adf then
      _TBSDR___(_TBSDopR___, x + self.x * 13 + 2, y + self.y * 13 + 2, 11, 11, Red)
    end
  end
end
lka_poi = {  Box = Image.load("Ciba/Images/Box.png") }
function lka_poi:_zzz_aii()
  lka_poi.newapo_ = {}
  if not lka_poi._atatx then
    local File = io.open("Ciba/IME.CFG", "r")
    lka_poi._atatx = File:read("*l")
  end
  if lka_poi._atatx == "Ciba/WB.IME" then
    lka_poi.emdax_ = 4
    lka_poi.Name = "Îå±Ê"
  elseif lka_poi._atatx == "Ciba/PY.IME" then
    lka_poi.emdax_ = 12
    lka_poi.Name = "Æ´Òô"
  end
  local File = io.open(lka_poi._atatx, "r")
  if not File then
    if lka_poi._atatx == "Ciba/WB.IME" then CF__eid("Ciba/WBIME.Dat", "Ciba/WB.IME") end
    if lka_poi._atatx == "Ciba/PY.IME" then CF__eid("Ciba/PYIME.Dat", "Ciba/PY.IME") end
  end
  if File then File:close() end
  for _atatx in io.lines(lka_poi._atatx) do
    for newabo_, _VVVVV_ in string.gfind(_atatx, "(%S+)%s(%S+)") do
      lka_poi.newapo_[newabo_] = _VVVVV_
    end
  end
end
function lka_poi:newAbo_()
  screen:blit(110, 75, self.Box)
  screen:flip()
  local _abc_xx_atatx = lka_poi._atatx
  lka_poi._atatx = nil
  while true do
    _KvS:_DU_il()
    if _KvS._RRRRaaa__RL then
      lka_poi._atatx = "WB.IME"
    elseif _KvS._RRRRaaa__RR then
      lka_poi._atatx = "PY.IME"
    end
    if lka_poi._atatx or _KvS._RRRRaaa__RD then break end
  end
  if lka_poi._atatx then
    local File = io.open("IME.CFG", "w")
    File:write(lka_poi._atatx)
    File:close()
    lka_poi:_zzz_aii()
  else
    lka_poi._atatx = _abc_xx_atatx
  end
  _KvS:_DU_il()
end
function _abc_xx:eee_haxxo(_abc_FFH)
  local _jlu_jlu = {}
  if _abc_FFH then
    if lka_poi.newapo_[_abc_FFH] then
      self.eee_seccc = lka_poi.newapo_[_abc_FFH]
      local IOPikalaaaaaaaa = string.find(self.eee_seccc, "/")
      t_TC_ = 1
      while true do 
        if IOPikalaaaaaaaa == nil then break end
        _jlu_jlu[t_TC_] = string.sub(self.eee_seccc, 1, IOPikalaaaaaaaa - 1)
        self.eee_seccc = string.sub(self.eee_seccc, IOPikalaaaaaaaa + 1)
        t_TC_ = t_TC_ + 1
        IOPikalaaaaaaaa = string.find(self.eee_seccc, "/")
      end
      _jlu_jlu[t_TC_] = self.eee_seccc
      return _jlu_jlu
    else
      return nil
    end
  end
end  
function _abc_xx:goxzy_()
  local Result = nil
  if _KvS.TTTHHHSSSSL and not _KvS.L then
    self._zzz_aa = not(self._zzz_aa)
  end
  if _KvS.L and _KvS.TTTHHHSSSSL then
    lka_poi:newAbo_()
  end
  self._zzz_ad = _KvS.L
  if _KvS.L and _KvS._T_KL_V then
    self:_zzz_aii()
    Result = "\n"
  end
  local L_H = _KvS:GGL_H()
  local L_V = _KvS:GGL_V()
  local R_H = _KvS:GGR_H()
  local R_V = _KvS:GGR_V()
  local Right_Keyed = (R_V ~= 0) or (R_H ~= 0)
  if _KvS.PRPRPR_LR then
    if not self.des_xz then
      self.des_xz = true
      if Right_Keyed then
        self.x = 7 + R_H
        self.y = 2 + R_V
      else
        self.x = 2 + L_H
        self.y = 2 + L_V
      end
    else
      self.x = _TBSDccRLT___(self.x + R_H + L_H, 0, 9)
      self.y = _TBSDccRLT___(self.y + R_V + L_V, 0, 4)
    end
    self._zzz_adf = string.sub(self.Palette[self._zzz_ad][self.y], self.x + 1, self.x + 1)
  else
    if self.des_xz then
      Result = self._zzz_adf
      self._zzz_adf = nil
      self.des_xz = false
    end
  end
  if self._zzz_aa then
    if eee_Lll then
      self._zzz_ab = false
    else
      _TBSDR___(screen, eee_X + 1, eee_Y - 15, 133, 14, Color.new(172,168,153))
      _TBSDR___(screen, eee_X, eee_Y - 16, 133, 14, Color.new(220,226,240))
      screen:drawLine(eee_X + 2, eee_Y - 3, eee_X + 132, eee_Y - 3, White)
      screen:drawLine(eee_X + 132, eee_Y - 14, eee_X + 132, eee_Y - 3, White)
      screen:fillRect(eee_X + 2, eee_Y - 14, 130, 11, Color.new(238,240,248))
      _MAFD_:print(eee_X + 3, eee_Y - 15, self.eee_Cab)
    end    
    local _zzz_adf_length = string.len(self.eee_Cab)
    if _KvS._RRRRaaa__ST then
      if _zzz_adf_length ~= 0 then
        self.eee_Cab = ""
      end
    end
    if Result == " " or _zzz_adf_length == lka_poi.emdax_ then
      if _zzz_adf_length > 0 then
        eee_Lll = self:eee_haxxo(self.eee_Cab)
        self.eee_Issssssss = self.eee_Cab
        self.eee_Cab = ""
        Result = nil
      else return Result
      end
    end
    if Result == "\b" and _zzz_adf_length > 0 then
      if _zzz_adf_length == 1 then self.eee_Cab = ""
      else self.eee_Cab = string.sub(self.eee_Cab, 1, _zzz_adf_length - 1) end
    elseif Result == "\b" and _zzz_adf_length == 0 then
      return Result
    elseif Result == "\t" then
      eee_Lll = self:eee_haxxo("#symbol")
      self.eee_Issssssss = nil
      self.eee_Cab = ""
      Result = nil
    elseif Result == "\n" then
      if _zzz_adf_length == 0 then
        return Result
      else
        Result = nil
      end
    elseif Result then
      local _zzz_adf_Byte = string.byte(Result)
      if _zzz_adf_Byte > 96 and _zzz_adf_Byte < 123 then
        if _zzz_adf_length < lka_poi.emdax_ then
          self.eee_Cab = self.eee_Cab .. Result
        end
      else
        return Result
      end
    end
  else
    return Result
  end
end
function _abc_xx:_DU_il()
  if self.eee_sssd then
    self.eee_sssd = false
    eee_Lll = nil
    self.eee_Lllt_TC_ = 1
    self.eee_ssss = false
    self._zzz_ab = true
  end
  if self._zzz_ab then
    return self:goxzy_()
  else
    self.eee_ssss = true
    screen:blit(eee_X, eee_Y - 130, self.goxzy_Box)
    local _jlu_jlu_t_TC_ = table.getn(eee_Lll)
    if _jlu_jlu_t_TC_ <= 8 then
      for t_TC_ = 1, _jlu_jlu_t_TC_ do
        screen:blit(eee_X + 4, eee_Y - 140 + (15 * t_TC_), self._TBS___, 1 + ( 18 * (t_TC_ - 1)), 1, 16, 16)
        _MAFD_:print(eee_X + 25, eee_Y - 138 + (15 * t_TC_), eee_Lll[t_TC_])
      end
    else
      local eee_ssss = math.floor(_jlu_jlu_t_TC_ / 8)
      local Remain = math.mod(_jlu_jlu_t_TC_, 8)
      if _KvS._T_KL_H then self.eee_Lllt_TC_ = self.eee_Lllt_TC_ - 1 end
      if _KvS._T_KL_V then self.eee_Lllt_TC_ = self.eee_Lllt_TC_ + 1 end
      if self.eee_Lllt_TC_ < 1 then self.eee_Lllt_TC_ = 1 end
      if self.eee_Lllt_TC_ > eee_ssss then
        if Remain == 0 then self.eee_Lllt_TC_ = eee_ssss
        else self.eee_Lllt_TC_ = eee_ssss + 1
        end
      end
     if self.eee_Lllt_TC_ == eee_ssss + 1 then
        for t_TC_ = 1, Remain do
          screen:blit(eee_X + 4, eee_Y - 140 + (15 * t_TC_), self._TBS___, 1 + ( 18 * (t_TC_ - 1)), 1, 16, 16)
          _MAFD_:print(eee_X + 25, eee_Y - 138 + (15 * t_TC_), eee_Lll[t_TC_ + (8 * (self.eee_Lllt_TC_ - 1))])        
        end
      else        
        for t_TC_ = 1, 8 do
          screen:blit(eee_X + 4, eee_Y - 140 + (15 * t_TC_), self._TBS___, 1 + ( 18 * (t_TC_ - 1)), 1, 16, 16)
          _MAFD_:print(eee_X + 25, eee_Y - 138 + (15 * t_TC_), eee_Lll[t_TC_ + (8 * (self.eee_Lllt_TC_ - 1))])        
        end
      end
    end
    local Index = self:goxzy_Ponewabo_()
    if Index then
      if Index == true then
        self.eee_sssd = true
        self.eee_seeea = false
        return
      end

      local goxzy_Poww = eee_Lll[(8 * (self.eee_Lllt_TC_ - 1)) + Index]
      self.eee_sssd = true
      if goxzy_Poww then
        local Issssssss
        if self.eee_Issssssss then
          Issssssss = self.eee_Issssssss
        elseif self.eee_seeea then
          Issssssss = string.sub(goxzy_Poww, 1, 2)
        end
        local Icccccccc = lka_poi.newapo_[Issssssss]
        if Icccccccc then
          Icccccccc = goxzy_Poww .. "/" .. string.gsub(Icccccccc, goxzy_Poww, "")
          Icccccccc = string.gsub(Icccccccc, "//", "/")
          if string.sub(Icccccccc, -1) == "/" then
            Icccccccc = string.sub(Icccccccc, 1, -2)
          end              
          lka_poi.newapo_[Issssssss] = Icccccccc
        end
        if lka_poi.newapo_[goxzy_Poww] then
          eee_Lll = self:eee_haxxo(goxzy_Poww)
          self.eee_Issssssss = nil
          self.eee_sssd = false
          self.eee_seeea = true
          self.eee_Lllt_TC_ = 1
          return goxzy_Poww
        else
          if self.eee_seeea and goxzy_Poww then
            goxzy_Poww = string.sub(goxzy_Poww, 3)
            self.eee_seeea = false
          end
       return goxzy_Poww
   end
 end
    end
  end
end
function _abc_xx:goxzy_Ponewabo_()
  if _KvS._RRRRaaa__RD then return 1
  elseif _KvS._RRRRaaa__RU then return 2
  elseif _KvS._RRRRaaa__RL then return 3
  elseif _KvS._RRRRaaa__RR then return 4
  elseif _KvS._RRRRDDD__U then return 5
  elseif _KvS._RRRRDDD__D then return 6
  elseif _KvS._RRRRDDD__L then return 7
  elseif _KvS._RRRRDDD__R then return 8
  elseif _KvS.TTTHHHSSSST then return true
  else return nil
  end
end
Ciba = {
  ECIDX   = {},  CEIDX   = {},  Skin    = Image.load("Ciba/Images/Skin.png"),  GO      = Image.load("Ciba/Images/GO.png"),  BaseDir = System.currentDirectory(),  EC = false,  CE = false}
EC = {}
CE = {}
About = {"Ó¢ººË«Ïò´Êµä","R¼ü»ò»Ø³µ²éÑ¯","Select¼üÇÐ»»Ó¢ÎÄ/ÖÐÎÄÊäÈë","L + Select¼üÇÐ»»Îå±Ê»òÆ´Òô","ÏêÏ¸²Ù×÷Ö¸ÄÏÇë²Î¿¼Readme.TXT","KRISHFWU@GMAIL.COM","KRIS 2006-02-20"}
function Ciba:_zzz_aii()
  IOPika = Font.load("Ciba/Ciba/Fonts/Phonetic.ttf")
  IOPika:setPixelSizes(0, 14)
  for _atatx in io.lines("Ciba/Ciba/ECIDX.IDX") do
    for Word, IOPikaujj in string.gfind(_atatx, "(%S+)%s(%S+)") do
      self.ECIDX[Word] = IOPikaujj
    end
  end
  for _atatx in io.lines("Ciba/Ciba/CE.IDX") do
    for Word, IOPikaujj in string.gfind(_atatx, "(%S+)%s(%S+)") do
      self.CEIDX[Word] = IOPikaujj
    end
  end
end
function CE:IOPikaull(IOPikajjjjjj)
  local CE_IOPikaullaa
  if string.len(IOPikajjjjjj) < 2 then return "Invalid keyword\n" end
  if string.sub(IOPikajjjjjj, -1) == "*" then
    CE_IOPikaullaa = true
    IOPikajjjjjj = string.sub(IOPikajjjjjj, 1, -2)
  else
    CE_IOPikaullaa = false
  end
  local KEY = string.sub(IOPikajjjjjj, 1, 2)
  if Ciba.CEIDX[KEY] then
    Ciba.CEDIC = io.open(Ciba.BaseDir .. "/Ciba/Ciba/CE.DIC", "r")
    Ciba.CEDIC:seek("set", Ciba.CEIDX[KEY])
    local Line = Ciba.CEDIC:read("*l")
    while true do
      if string.find(Line, IOPikajjjjjj) then
        if CE_IOPikaullaa then
      IOPikalaaaaaaaa = Ciba.CEDIC:read("*l")
          return Line
     else
    local Word, Num
          Num = string.find(Line, "\t")
          Word = string.sub(Line, 1, Num - 1)
    if string.len(Word) == string.len(IOPikajjjjjj) then
      IOPikalaaaaaaaa = Ciba.CEDIC:read("*l")
     return Line
          end
        end
      end
      Line = Ciba.CEDIC:read("*l")
      if not Line then return "Not found\n" end
      if string.byte(Line, 1) > string.byte(IOPikajjjjjj, 1) then return "Not found\n" end
    end
  else
    return "Not found\n"
  end
end
function CE:mxmxae(Icccccccc)
  local _jlu_jlu = {}
  EC.IOPika = false
  Int = string.find(Icccccccc, "\t")
  local Sub = string.sub(Icccccccc, Int + 1)
  _jlu_jlu[1] = string.sub(Icccccccc, 1, Int - 1)
  t_TC_ = 1
  while true do
    t_TC_ = t_TC_ + 1
    Int = string.find(Sub, "|")
    if Int then
      _jlu_jlu[t_TC_] = string.sub(Sub, 1, Int - 1)
      Sub = string.sub(Sub, Int + 1)
    else
      _jlu_jlu[t_TC_] = Sub
      break
    end
  end
  return _jlu_jlu
end
function EC:IOPikaull(IOPikajjjjjj)
  local Word_IDX, IOPikalrrrrrrrrrratatx, Line, IOPikalllllll, Sentence, IOPikaullaa
  local IOPikaliiiiiii = string.lower(IOPikajjjjjj)
  local KW_Byte = string.byte(IOPikaliiiiiii, 1)
  if KW_Byte < 97 or KW_Byte > 122 then return "Invalid keyword\n" end
  local KW_Len = string.len(IOPikajjjjjj)
  if string.sub(IOPikaliiiiiii, -1) == "*" then
    IOPikaullaa = true
    IOPikaliiiiiii = string.sub(IOPikaliiiiiii, 1, -2)
    KW_Len = KW_Len - 1
  else
    IOPikaullaa = false
  end
  if KW_Len > 1 then
  Word_IDX = string.sub(IOPikaliiiiiii, 1, 2)
    if string.byte(IOPikaliiiiiii, 2) < 97 or string.byte(IOPikaliiiiiii, 1) > 122 then
      Word_IDX = string.sub(IOPikaliiiiiii, 1, 1)
    end
    if string.find(IOPikajjjjjj, " ") then Sentence = true end
  elseif KW_Len == 1 then
    Word_IDX = IOPikaliiiiiii
  end
  local IDX_Len = string.len(Word_IDX)
  if Ciba.ECIDX[Word_IDX] then
    Ciba.EC_IDX = io.open(Ciba.BaseDir .. "/Ciba/Ciba/EC.IDX", "r")
    Ciba.EC_IDX:seek("set", Ciba.ECIDX[Word_IDX])
    local Not_Found = true
    KW_Len = string.len(IOPikaliiiiiii)
    IOPikaliiiiiii = string.gsub(IOPikaliiiiiii, "(%p)", "%%%1")
    while Not_Found do
      IOPikalrrrrrrrrrratatx = Ciba.EC_IDX:read("*l")
      Line = string.sub(IOPikalrrrrrrrrrratatx, 1, string.find(IOPikalrrrrrrrrrratatx, "\t") - 1)
    IOPikalllllll = string.lower(Line)
      if not Line then return "Not found\n" end
      if IDX_Len > 1 and string.byte(IOPikalllllll, 2) > string.byte(IOPikaliiiiiii, 2) then return "Not found\n" end
      if string.byte(IOPikalllllll, 1) > string.byte(IOPikaliiiiiii, 1) then return "Not found\n" end
      if Sentence then
        if string.find(IOPikalllllll, IOPikaliiiiiii) then
          Not_Found = false
      end
      else
        local Div = string.find(IOPikalllllll, " ")
        if Div then IOPikalllllll = string.sub(IOPikalllllll, 1, Div - 1) end
        if IOPikaullaa then
          if string.find(IOPikalllllll, IOPikaliiiiiii) then
            Not_Found = false
          end
       else
      if string.find(IOPikalllllll, IOPikaliiiiiii) and string.len(IOPikalllllll) == KW_Len then
            Not_Found = false
   end
     end
      end
    end
  IOPikalaaaaaaaa = Ciba.EC_IDX:read("*l")
    if string.lower(string.sub(IOPikalaaaaaaaa, 1, string.find(IOPikalaaaaaaaa, "\t") - 1)) ==
       string.lower(string.sub(IOPikalrrrrrrrrrratatx, 1, string.find(IOPikalrrrrrrrrrratatx, "\t") - 1)) then
      local Line = IOPikalaaaaaaaa
      IOPikalaaaaaaaa = Ciba.EC_IDX:read("*l")
    end
    return IOPikalrrrrrrrrrratatx
  else
    return "Invalid keyword\n"
  end
end
function EC:mxmxae(Word_atatx)
local Icccccccc
  self.IOPika = false
  for Offset, Size in string.gfind(Word_atatx, "%S\t(%S+)\t(%S+)") do
    local ECDIC = io.open(Ciba.BaseDir .. "/Ciba/Ciba/EC.DIC", "r")
    ECDIC:seek("set", tonumber(Offset))
    Icccccccc = ECDIC:read(tonumber(Size))
    ECDIC:close()
  end
  local _jlu_jlu = {}
  Int = string.find(Icccccccc, "\t")
local Sub = string.sub(Icccccccc, Int + 1)
  _jlu_jlu[1] = string.sub(Icccccccc, 1, Int - 1)
  t_TC_ = 1
  while true do
    t_TC_ = t_TC_ + 1
    Int = string.find(Sub, "|")
    if Int then
      _jlu_jlu[t_TC_] = string.sub(Sub, 1, Int - 1)
     Sub = string.sub(Sub, Int + 1)
    else
      _jlu_jlu[t_TC_] = Sub
      break
    end
  end
  if string.find(_jlu_jlu[2], "%*%[(.+)%]") then
    self.IOPika = true
    _, _, _VVVVV_ = string.find(_jlu_jlu[2], "%*%[(.+)%]")
   _jlu_jlu[2] = _VVVVV_
  end
  return _jlu_jlu
end
function Ciba:Ciba(IOPikajjjjjj)
  local Word_atatx
  local _jlu_jlu
  local Result = {}
 if not IOPikajjjjjj or IOPikajjjjjj == "" then
    Result[1] = "Expected keyword\n"
    EC.IOPika = false
    return Result
  end
  self.EC = false
  self.CE = false
  if string.byte(IOPikajjjjjj) > 160 then
    self.CE = true
  else
    self.EC = true
  end
  if self.EC then
  Word_atatx = EC:IOPikaull(IOPikajjjjjj)
  elseif self.CE then
    Word_atatx = CE:IOPikaull(IOPikajjjjjj)
  end
  if string.find(Word_atatx, "\t") then
    if self.EC then
      _jlu_jlu = EC:mxmxae(Word_atatx)
    elseif self.CE then
      _jlu_jlu = CE:mxmxae(Word_atatx)
   end
  Result = _jlu_jlu
else
    EC.IOPika = false
  Result[1] = Word_atatx
  end
  if self.EC then
    if Ciba.EC_IDX then
      Ciba.EC_IDX:close()
      Ciba.EC_IDX = nil
    end
 elseif self.CE then
    if Ciba.CEDIC then
      Ciba.CEDIC:close()
      Ciba.CEDIC = nil
    end
  end
  return Result
end
do
  local _jlu_jlu = About
  local IOPikajjjjjj = ""
local OSK_State = ""
  local CurPos = 0
  local OSK = _abc_xx.new()
  lka_poi:_zzz_aii()
  Ciba:_zzz_aii()
  while true do
 _KvS:_DU_il()
    screen:blit(0, 0, Ciba.Skin)
    if _jlu_jlu then
      local t_TC_ = 2
      if EC.IOPika then
        screen:fontPrint(IOPika, 168, 48 + 38, "/ ".._jlu_jlu[2].." /", mxmxaeee)
  t_TC_ = 3
      end
      local x, y = 0, 48 + 14 * t_TC_
      _MAFD_:print(168, 48 + 14, _jlu_jlu[1])
      while _jlu_jlu[t_TC_] do
    x, y = _MAFD_:print(168, y, _jlu_jlu[t_TC_], screen, false, 460, 14)
        y = y + 14
        t_TC_ = t_TC_ + 1
      end
    end
    OSK._zzz_ac = true
    local Len = string.len(IOPikajjjjjj)
   local Wait = 0
    _MAFD_:print(40, 28, IOPikajjjjjj)
    screen:drawLine(40 + Len * 6, 28, 40 + Len * 6, 28 + 11, Color.new(0, 0, 255))
    _MAFD_:print(30, 252, OSK_State)
    if OSK._zzz_ac then
      local In = OSK:_DU_il()
 OSK:des_xzaw(screen, 8, 181)
      if OSK._zzz_aa then OSK_State = lka_poi.Name
      elseif OSK._zzz_ab then OSK_State = "En"
end
      if In == "\b" and IOPikajjjjjj ~= "" then
        if string.byte(IOPikajjjjjj, Len) > 128 then
    IOPikajjjjjj = string.sub(IOPikajjjjjj, 1, Len - 2)
        else
          IOPikajjjjjj = string.sub(IOPikajjjjjj, 1, Len - 1)
        end
      elseif In == "\n" or (_KvS._T_KL_V and not OSK.eee_ssss) then
        screen:blit(342, 26, Ciba.GO)
        screen:flip()
  Wait = 10
        if IOPikajjjjjj == "" then
          DoIOPikalaaaaaaaa = true
     if IOPikalaaaaaaaa then
            IOPikajjjjjj = string.sub(IOPikalaaaaaaaa, 1, string.find(IOPikalaaaaaaaa, "\t") - 1)
          end
        end
   _jlu_jlu = Ciba:Ciba(IOPikajjjjjj)
        IOPikajjjjjj = ""
        DoIOPikalaaaaaaaa = false
      elseif In ~= nil and Len < 48 then
        if string.byte(In) >= 32 then
        IOPikajjjjjj = IOPikajjjjjj .. In
        end
      end
 else
      OSK_State = "Off"
    end
    screen.waitVblankStart(Wait)
    screen:flip()
    if _KvS.ST and _KvS.L and _KvS.R then break end
  end
end